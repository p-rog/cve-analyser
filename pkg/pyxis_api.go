package helper

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"net/http"
	"sort"
	"strings"
)

const PyxisUrl string = "https://catalog.redhat.com/api/containers/v1"
const RepoToCPEUrl string = "https://www.redhat.com/security/data/metrics/repository-to-cpe.json"

type PyxisResponseCPE struct {
	Data []struct {
		Arch        string   `json:"architecture"`
		CPEs        []string `json:"cpe_ids"`
		ContentSets []string `json:"content_sets"`
	} `json:"data"`
}

type RepoData struct {
	CPEsInRepo []string `json:"cpes"`
}

type RepoToCPEmap struct {
	Data map[string]RepoData `json:"data"`
}

type PyxisResponseImageID struct {
	Data []struct {
		Arch string `json:"architecture"`
		ID   string `json:"_id"`
	} `json:"data"`
}

type PyxisResponseRPMmanifest struct {
	RPMs []struct {
		Name       string `json:"name"`
		SRPM_NAME  string `json:"srpm_name"`
		SRPM_NEVRA string `json:"srpm_nevra"`
	} `json:"rpms"`
}

func unique(s []string) []string {
	inResult := make(map[string]bool)
	var result []string
	for _, str := range s {
		if _, ok := inResult[str]; !ok {
			inResult[str] = true
			result = append(result, str)
		}
	}
	return result
}

func repomap(repository string, name string) string {
	var result string
	switch {
	case repository == "rh-acs":
		result += "advanced-cluster-security/"
		switch{
		case name == "main":
			result += "rhacs-main-rhel8"
		case name == "collector":
			result += "rhacs-collector-rhel8"
		case name == "scanner":
			result += "rhacs-scanner-rhel8"
		case name == "scanner-db":
			result += "rhacs-scanner-db-rhel8"
		}
	default:
		result += repository + "/" + name
	}
	return result
}

func CallPyxis_CPE(repository string, name string, tag string, CPEtoRepos RepoToCPEmap) []string {
	var AllCPEs []string

	url := PyxisUrl + "/repositories/registry/registry.access.redhat.com/repository/" + repomap(repository, name) + "/tag/" + tag

	resp, err := http.Get(url)
	if err != nil {
		fmt.Println("No response from request")
	}
	defer resp.Body.Close()
	body, err := ioutil.ReadAll(resp.Body) // response body is []byte

	var result PyxisResponseCPE
	if err := json.Unmarshal(body, &result); err != nil { // Parse []byte to the go struct pointer
		fmt.Println("Can not unmarshal JSON")
	}

	// collecting CPEs from image repository
	var dirty_cpe_ids []string
	for _, look := range result.Data {
		if look.Arch == "amd64" {
			dirty_cpe_ids = append(dirty_cpe_ids, look.CPEs...)
		}
	}
	// generate list of CPEs with sw_edition and without
	var cpe_ids []string
	var clean_cpe_ids []string
	var ocp_cpe string
	for _, look := range dirty_cpe_ids {
		clean_cpe_ids = strings.Split(look, "::")
		cpe_ids = append(cpe_ids, clean_cpe_ids[0])
		cpe_ids = append(cpe_ids, look)
		if strings.Contains(clean_cpe_ids[0], "openshift") {
			ocp_cpe = strings.Split(clean_cpe_ids[0], ".")[0]
			cpe_ids = append(cpe_ids, ocp_cpe)
		}
	}
	//
	// generate list of CPEs based on the image content sets
	var otherCPEs []string
	var clean_otherCPEs []string
	var content_sets []string
	var reposCPEs []string

	for _, look := range result.Data {
		if look.Arch == "amd64" {
			content_sets = append(content_sets, look.ContentSets...)
		}
	}
	for _, look1 := range content_sets {
		for k, look2 := range CPEtoRepos.Data {
			if k == look1 {
				otherCPEs = append(otherCPEs, look2.CPEsInRepo...)
			}
		}
	}
	for _, look := range otherCPEs {
		clean_otherCPEs = strings.Split(look, "::")
		reposCPEs = append(reposCPEs, clean_otherCPEs[0])
		reposCPEs = append(reposCPEs, look)
	}

	AllCPEs = append(cpe_ids, reposCPEs...)

	//
	// extra step for jenkins containers due to incorrect CPEs in the image metadata
	// when jenkins image CPE metadata will be fixed below code can be removed
	if strings.Contains(name, "jenkins") {
		AllCPEs = append(AllCPEs, "cpe:/o:redhat:enterprise_linux:8")
	}
	//
	// return all CPEs for the container
	return unique(AllCPEs)
}

func CallRepoToCPE() RepoToCPEmap {
	resp, err := http.Get(RepoToCPEUrl)
	if err != nil {
		fmt.Println("No response from request")
	}
	defer resp.Body.Close()
	body, err := ioutil.ReadAll(resp.Body) // response body is []byte

	var results RepoToCPEmap
	if err := json.Unmarshal(body, &results); err != nil {
		fmt.Println("Can not unmarshal JSON")
	}
	//fmt.Println(results)
	return results
}

func CallPyxis_ImageID(repository string, name string, tag string) string {

	url := PyxisUrl + "/repositories/registry/registry.access.redhat.com/repository/" + repomap(repository, name) + "/tag/" + tag
	//fmt.Println(url)

	// Get request
	resp, err := http.Get(url)
	if err != nil {
		fmt.Println("No response from request")
	}
	defer resp.Body.Close()
	body, err := ioutil.ReadAll(resp.Body) // response body is []byte

	var result PyxisResponseImageID
	if err := json.Unmarshal(body, &result); err != nil { // Parse []byte to the go struct pointer
		fmt.Println("Can not unmarshal JSON")
	}

	var imageID string
	for _, look := range result.Data {
		if look.Arch == "amd64" {
			imageID = look.ID
		}
	}
	return imageID
}

func CallPyxis_RPMs(imageID string) []string {
	url := PyxisUrl + "/images/id/" + imageID + "/rpm-manifest"

	resp, err := http.Get(url)
	if err != nil {
		fmt.Println("No response from request")
	}
	defer resp.Body.Close()
	body, err := ioutil.ReadAll(resp.Body) // response body is []byte

	var result PyxisResponseRPMmanifest
	if err := json.Unmarshal(body, &result); err != nil { // Parse []byte to the go struct pointer
		fmt.Println("Can not unmarshal JSON")
	}

	var manifest []string
	for _, look := range result.RPMs {
		manifest = append(manifest, strings.Split(look.SRPM_NEVRA, ":")[0]) // collecting src packages names as image manifest, split by ":"
	}
	sort.Strings(manifest)
	return unique(manifest)
}
