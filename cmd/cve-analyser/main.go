package main

import (
	"encoding/csv"
	"encoding/json"
	"fmt"
	"io"
	"os"
	"strings"
	"sync"

	helper "github.com/p-rog/cve-analyser/pkg"
)

type Output struct {
	CVE         string
	Severity    string
	Component   string
	Information string
}

func PrettyPrint(i interface{}) string {
	s, _ := json.MarshalIndent(i, "", "\t")
	return string(s)
}

func fileExist(file_name string) bool {
	info, err := os.Stat(file_name)
	if os.IsNotExist(err) {
		return false
	}
	return !info.IsDir()
}

func processLines(wg *sync.WaitGroup, jobs <-chan []string, results chan<- Output, CPEtoRepos helper.RepoToCPEmap) {
	defer wg.Done()
	for line_data := range jobs {
		//Collecting and grepping security data
		cve_id := line_data[0]
		//fmt.Printf("%v", cve_id)
		result := helper.CallHydra(cve_id)

		var image_Repo string
		var image_Name string
		var image_Tag string
		var image_cpe_info []string
		var info_fixed []string
		var info_not_fixed []string
		var Information string
		var non_rpm_fixes_status []string
		var non_rpm_not_fixed_status []string
		var Product_impact string
		var imageID string
		var image_rpm_manifest []string

		//Collecting information about the reported component (package or container image)
		if strings.Contains(line_data[1], "/") {
			image_Repo = strings.Split(line_data[1], "/")[0]
			if strings.Contains(line_data[1], ":") {
				image_Name = strings.Split(strings.Split(line_data[1], "/")[1], ":")[0]
				image_Tag = strings.Split(strings.Split(line_data[1], "/")[1], ":")[1]
			} else {
				image_Name = strings.Split(line_data[1], "/")[1]
				image_Tag = "latest"
			}
			//fmt.Printf("%v\n%v\n%v\n", image_Repo, image_Name, image_Tag)

			image_cpe_info = helper.CallPyxis_CPE(image_Repo, image_Name, image_Tag, CPEtoRepos)
			//fmt.Println(PrettyPrint(image_cpe_info))

			imageID = helper.CallPyxis_ImageID(image_Repo, image_Name, image_Tag)
			//fmt.Println(imageID)

			image_rpm_manifest = helper.CallPyxis_RPMs(imageID)
			//fmt.Println(PrettyPrint(image_rpm_manifest))

			//Searching for non_rpm fixes based on the container name
			container_name := image_Repo + "/" + image_Name
			for _, addressed := range result.Data_Fixed {
				if strings.Contains(addressed.RPM, container_name) {
					if len(addressed.Product_impact) == 0 {
						Product_impact = fmt.Sprintf("%v%v", "Product impact:", strings.ToLower(result.Severity))
					} else {
						Product_impact = fmt.Sprintf("%v%v", "Product impact:", strings.ToLower(addressed.Product_impact))
					}
					non_rpm_fixes_status = append(non_rpm_fixes_status, fmt.Sprintf("(%+v|%+v|%+v|%+v)", addressed.Product_name, Product_impact, addressed.Advisory, addressed.RPM))
				}
			}
			for _, not_addressed := range result.Data_NotFixed {
				if strings.Contains(not_addressed.RPM, container_name) {
					if len(not_addressed.Product_impact) == 0 {
						Product_impact = fmt.Sprintf("%v%v", "Product impact:", strings.ToLower(result.Severity))
					} else {
						Product_impact = fmt.Sprintf("%v%v", "Product impact:", strings.ToLower(not_addressed.Product_impact))
					}
					if not_addressed.Fix_State == "Not affected" {
						non_rpm_not_fixed_status = append(non_rpm_not_fixed_status, fmt.Sprintf("(%+v|%+v|%+v)", not_addressed.Product_name, not_addressed.Fix_State, not_addressed.RPM))
					} else {
						non_rpm_not_fixed_status = append(non_rpm_not_fixed_status, fmt.Sprintf("(%+v|%+v|%+v|%+v)", not_addressed.Product_name, Product_impact, not_addressed.Fix_State, not_addressed.RPM))
					}
				}
			}
			if len(non_rpm_fixes_status) == 0 && len(non_rpm_not_fixed_status) == 0 {
				//Searching for rpm fixes based on the CPE
				for _, cpe := range image_cpe_info {
					for _, lookFixed := range result.Data_Fixed {
						if len(lookFixed.Product_impact) == 0 {
							Product_impact = fmt.Sprintf("%v%v", "Product impact:", strings.ToLower(result.Severity))
						} else {
							Product_impact = fmt.Sprintf("%v%v", "Product impact:", strings.ToLower(lookFixed.Product_impact))
						}
						if strings.Contains(lookFixed.CPE, "openshift") {
							lookFixed.CPE = strings.Split(lookFixed.CPE, ".")[0]
						}
						if lookFixed.CPE == cpe {
							for _, rpm := range image_rpm_manifest {
								if rpm == strings.Split(lookFixed.RPM, ":")[0] {
									info_fixed = append(info_fixed, fmt.Sprintf("(%+v|%+v|%+v|%+v)", lookFixed.Product_name, Product_impact, lookFixed.Advisory, lookFixed.RPM))
								}
							}
						}
					}
					for _, lookNotFixed := range result.Data_NotFixed {
						if len(lookNotFixed.Product_impact) == 0 {
							Product_impact = fmt.Sprintf("%v%v", "Product impact:", strings.ToLower(result.Severity))
						} else {
							Product_impact = fmt.Sprintf("%v%v", "Product impact:", strings.ToLower(lookNotFixed.Product_impact))
						}
						// when the flaw is not fixed then the default CPE remains, it's not necessary to check exact openshift stream
						//if strings.Contains(lookNotFixed.CPE, "openshift") {
						//	lookNotFixed.CPE = strings.Split(lookNotFixed.CPE, ".")[0]
						//}
						if lookNotFixed.CPE == cpe {
							for _, rpm := range image_rpm_manifest {
								// If the component is not affected, then the component name might be a little different than the full source rpm package name
								// hence it's better to check if the container rpm manifest contains a package similar to the not affected rpm package name
								//if rpm == strings.Split(lookNotFixed.RPM, ":")[0] {
								if strings.Contains(rpm, lookNotFixed.RPM) {
									if lookNotFixed.Fix_State == "Not affected" {
										info_not_fixed = append(info_not_fixed, fmt.Sprintf("(%+v|%+v|%+v)", lookNotFixed.Product_name, lookNotFixed.Fix_State, lookNotFixed.RPM))
									} else {
										info_not_fixed = append(info_not_fixed, fmt.Sprintf("(%+v|%+v|%+v|%+v)", lookNotFixed.Product_name, Product_impact, lookNotFixed.Fix_State, lookNotFixed.RPM))
									}
								}
							}
						}
					}
				}
			}
		} else {
			//Fuzzy searching if as a component there is only a name of package, not a container image
			component_name := line_data[1]
			for _, addressed := range result.Data_Fixed {
				if len(addressed.Product_impact) == 0 {
					Product_impact = fmt.Sprintf("%v%v", "Product impact:", strings.ToLower(result.Severity))
				} else {
					Product_impact = fmt.Sprintf("%v%v", "Product impact:", strings.ToLower(addressed.Product_impact))
				}
				if strings.Contains(addressed.RPM, component_name) {
					info_fixed = append(info_fixed, fmt.Sprintf("(%+v|%+v|%+v|%+v)", addressed.Product_name, Product_impact, addressed.Advisory, addressed.RPM))
				}
			}
			for _, not_addressed := range result.Data_NotFixed {
				if len(not_addressed.Product_impact) == 0 {
					Product_impact = fmt.Sprintf("%v%v", "Product impact:", strings.ToLower(result.Severity))
				} else {
					Product_impact = fmt.Sprintf("%v%v", "Product impact:", strings.ToLower(not_addressed.Product_impact))
				}
				if strings.Contains(not_addressed.RPM, component_name) {
					if not_addressed.Fix_State == "Not affected" {
						info_not_fixed = append(info_not_fixed, fmt.Sprintf("(%+v|%+v|%+v)", not_addressed.Product_name, not_addressed.Fix_State, not_addressed.RPM))
					} else {
						info_not_fixed = append(info_not_fixed, fmt.Sprintf("(%+v|%+v|%+v|%+v)", not_addressed.Product_name, Product_impact, not_addressed.Fix_State, not_addressed.RPM))
					}
				}
			}
		}

		//Generating the results
		if len(info_fixed) == 0 && len(info_not_fixed) == 0 && len(non_rpm_fixes_status) == 0 && len(non_rpm_not_fixed_status) == 0 {
			Information = "Not Found Any Information"
		} else {
			output1 := strings.Join(info_fixed, "")
			output2 := strings.Join(info_not_fixed, "")
			output3 := strings.Join(non_rpm_fixes_status, "")
			output4 := strings.Join(non_rpm_not_fixed_status, "")
			Information = fmt.Sprintf("%v%v%v%v", output1, output2, output3, output4)
		}
		// Summary := new(Output)
		var summary Output
		summary.CVE = cve_id
		summary.Component = line_data[1]
		summary.Severity = fmt.Sprintf("%v%v", "CVE Severity:", result.Severity)
		summary.Information = Information

		results <- summary
	}
}

func main() {
	// Verification if provided file with data exists or not
	if len(os.Args) < 2 {
		fmt.Println("File to check is not provided")
		os.Exit(1)
	}
	file_name := os.Args[1]
	if !fileExist(file_name) {
		fmt.Println("file to check is incorrect or not exist")
		os.Exit(1)
	}

	// Opening the file
	file, err := os.Open(file_name)
	if err != nil {
		fmt.Println("failed opening file")
	}
	defer file.Close()

	data := csv.NewReader(file)

	// Checking the data
	jobs := make(chan []string)
	results := make(chan Output, 10000)

	wg := sync.WaitGroup{}

	// collect repositories to CPE mapping
	var CPEtoRepos helper.RepoToCPEmap = helper.CallRepoToCPE()

	// initiate 10 threads
	for w := 0; w < 1; w++ {
		wg.Add(1)
		go processLines(&wg, jobs, results, CPEtoRepos)
	}

	for {
		line_data, err := data.Read()
		if err == io.EOF {
			break
		}

		jobs <- line_data
	}

	close(jobs)
	wg.Wait()
	close(results)

	// Printing results
	for r := range results {
		fmt.Printf("%v,%v,%v,%v\n", r.CVE, r.Component, r.Severity, r.Information)
	}
}
